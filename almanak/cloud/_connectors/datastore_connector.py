# Standard library
from os import environ as env
from datetime import datetime
from uuid import uuid4

# Third party
from google.cloud import datastore

# Application libraries
from almanak.cloud.constants import PERSISTENT_RESOURCES, TEMPORAL_RESOURCES


PROJECTS = ['aarhusiana', 'openaws', 'almanak']

class DatastoreConnector(project=None):
    """Entities, CRUD
    Autosuggest, LIST
    Records, GET, LIST
    Assets, CRUD
    """
    def __init__(self, project):
        # if project not in PROJECTS:
        #     raise ValueError('Invalid projectname')
        cfg = env.get( project + '_APPLICATION_CREDENTIALS')
        self.client = datastore.Client.from_service_account_json(cfg)

    def _insert(self, resource, data):
        """data is a dict
        These keys can change without the function having to change. All
        that is required are the required keys
        """
        # Use uuid4 or GCP-autogenerated key
        if resource in PERSISTENT_RESOURCES:
            key = self.client.key(resource, str(uuid4()))
        elif resource in TEMPORAL_RESOURCES:
            key = self.client.key(resource)
        else:
            raise ValueError('Invalid resource-argument.')

        # Initialize and populate
        entity = datastore.Entity(key=key)
        entity.update(data)
        try:
            self.client.put(entity)
            return {'status': 200, 'data': entity}
        except Exception as e:
            return {'error': e}

    def _get(self, resource, _id):
        """_id is a uuid4-string or GCP-autogenerated Key
        """
        try:
            entity = self.client.get(self.client.key(resource, _id))
            return {'status': 200, 'data': entity} 
        except Exception as e:
            return {'error': e}
        
    def _list(self, resource, filters=[], projection=[], sort=[]):
        """Fetches list of resources.

        Args:
            resource (str): the resourcetype to list, eg. 'events', 'records'
            filters (list): [ ('name', '=', 'eva'), ('age', '>' , '5') ] 
            projection (list): ['address', 'name']
            sort (list): prefix with '-' to order desc ['created', '-priority']
            # limit (int): number of entities to fetch
        Returns:
            List of resources matching the supplied filters, if any.
        """

        query = self.client.query(kind=resource)
        for tup in filters:
            query.add_filter(*tup)

        if projection:
            query.projection = projection

        if sort:
            sorts = []
            for field in sort:
                sorts.append(field)
        try:
            return {'status': 200, 'data': list(query.fetch())}
        except Exception as e:
            return {'error': e}

    def _update(self, resource, _id, data):
        with self.client.transaction():
            entity = self.client.get(self.client.key(resource, _id))
            entity.update(data)
            self.client.put(entity)

    def _delete(self,resource, _id):
        return self.client.delete(self.client.key(resource, _id))
